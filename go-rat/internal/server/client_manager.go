package server

import (
	"log"
	"net"
	"strings"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"github.com/google/uuid" // For generating unique connection IDs
)

// ClientInfo holds details about a connected stub client.
type ClientInfo struct {
	ID          string          // Unique ID for this connection (generated by server)
	StubID      string          // From stub's auth message (e.g., a unique identifier of the stub itself)
	OS          string          // Operating system of the stub
	Arch        string          // Architecture of the stub
	IPAddress   string          // IP address of the stub
	ConnectTime time.Time       // Time when the stub connected
	Conn        *websocket.Conn // Active WebSocket connection to the stub
	// LastHeartbeat time.Time // Could be added for tracking active connections
}

var (
	clients    = make(map[string]*ClientInfo) // map[connectionID]*ClientInfo
	clientsMux sync.RWMutex
)

// AddClient adds a new client to the manager.
// It generates a unique ID for the connection.
func AddClient(conn *websocket.Conn, stubID, osType, arch, remoteAddr string) *ClientInfo {
	clientsMux.Lock()
	defer clientsMux.Unlock()

	ip, _, err := net.SplitHostPort(strings.TrimSpace(remoteAddr))
	if err != nil {
		log.Printf("Error parsing remote address '%s': %v. Using full address.", remoteAddr, err)
		ip = remoteAddr
	}

	// Generate a unique ID for this specific connection instance
	connectionID := uuid.New().String()

	client := &ClientInfo{
		ID:          connectionID,
		StubID:      stubID,
		OS:          osType,
		Arch:        arch,
		IPAddress:   ip,
		ConnectTime: time.Now(),
		Conn:        conn,
	}
	clients[connectionID] = client
	log.Printf("Client added: ID=%s, StubID=%s, IP=%s. Total clients: %d", connectionID, stubID, ip, len(clients))
	return client
}

// RemoveClient removes a client from the manager by its connection ID.
func RemoveClient(connectionID string) {
	clientsMux.Lock()
	defer clientsMux.Unlock()

	client, ok := clients[connectionID]
	if ok {
		// Optionally, perform any cleanup related to the client or its connection
		// For example, if the connection isn't already closed, close it.
		// client.Conn.Close() // Be careful if CloseHandler also calls RemoveClient to avoid deadlocks/loops.
		delete(clients, connectionID)
		log.Printf("Client removed: ID=%s, StubID=%s. Total clients: %d", connectionID, client.StubID, len(clients))
	} else {
		log.Printf("Attempted to remove non-existent client with ID: %s", connectionID)
	}
}

// GetClientByID retrieves a client by its connection ID. RLock for read-only access.
func GetClientByID(connectionID string) (*ClientInfo, bool) {
	clientsMux.RLock()
	defer clientsMux.RUnlock()
	client, ok := clients[connectionID]
	return client, ok
}

// GetAllClients retrieves a list of all connected clients.
func GetAllClients() []*ClientInfo {
	clientsMux.RLock()
	defer clientsMux.RUnlock()

	if len(clients) == 0 {
		return []*ClientInfo{} // Return empty slice, not nil
	}

	list := make([]*ClientInfo, 0, len(clients))
	for _, client := range clients {
		list = append(list, client)
	}
	return list
}

// ConfigureCloseHandler sets up the close handler for a WebSocket connection
// to ensure the client is removed from the manager upon disconnection.
func ConfigureCloseHandler(conn *websocket.Conn, connectionID string) {
	originalCloseHandler := conn.CloseHandler()
	conn.SetCloseHandler(func(code int, text string) error {
		log.Printf("Connection closed for client ID %s: code=%d, text='%s'", connectionID, code, text)
		RemoveClient(connectionID)
		// Call the original close handler if it exists and performed other duties
		if originalCloseHandler != nil {
			return originalCloseHandler(code, text)
		}
		return nil // Default behavior if no original handler or original was nil
	})
}
